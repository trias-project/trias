% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spread_with_multiple_values.R
\name{spread_with_multiple_values}
\alias{spread_with_multiple_values}
\title{Spread key-value pairs across multiple columns.}
\usage{
spread_with_multiple_values(data, key, value, fill = NA,
  convert = FALSE, drop = TRUE, sep = NULL, aggfunc = NULL, ...)
}
\arguments{
\item{data}{A dataframe.}

\item{key, value}{Column names or positions. This is passed to
\code{\link[tidyselect]{vars_pull}}. These arguments are passed by
expression and support \code{\link[rlang]{quasiquotation}} (you can unquote
column names or column positions)}

\item{fill}{If set, missing values will be replaced with this value.}

\item{convert}{If \code{TRUE}, \code{\link[utils]{type.convert}} with
\code{asis = TRUE} will be run on each of the new columns. This is useful
if the value column was a mix of variables that was coerced to a string. If
the class of the value column was factor or date, note that will not be
true of the new columns that are produced, which are coerced to character
before type conversion.}

\item{drop}{If \code{FALSE}, will keep factor levels that don't appear in the
data, filling in missing combinations with \code{fill}.}

\item{sep}{If \code{NULL}, the column names will be taken from the values of
\code{key} variable. If non-\code{NULL}, the column names will be given by
"<key_name><sep><key_value>".}

\item{aggfunc}{Aggregation function. Default: NULL (keep all values on
different rows)}
}
\value{
A data.frame.
}
\description{
This function spread one or more key-value pairs across multiple
  columns. If only one value exists per key, then this functions returns the
  same output as \code{\link[tidyr]{spread}}. Otherwise, aggregation function
  \code{aggfunc} is applied. If no function is passed, then the key-value(s)
  are spread on multiple rows.
}
\examples{
\dontrun{
test1 <- data.frame(
col1 = c(1, 1, 1, 1),
col2 = c("H", "H", "H", "H"),
key = c("A", "B", "C", "C"),
value = c("R", "S", "T", "X"),
stringsAsFactors = FALSE
)
spread_with_multiple_values(test1, key, value)
spread_with_multiple_values(test1, 3, 4)
spread_with_multiple_values(test1, -2, -1)
spread_with_multiple_values(test1, "key", "value")

# with NAs
test2 <- data.frame(
col1 = c(1, 1, 1, 2),
key = c("A", "C", "C", "A"),
value = c("R", "T", "X", "R"),
stringsAsFactors = FALSE
)
spread_with_multiple_values(test2, key, value)
spread_with_multiple_values(test2, key, value, fill = "No idea")

# apply aggregate function
test3 <- data.frame(
col1 = c(1,1,1,1),
  col2  = c("H", "H", "H", "H"),
  key = c("A", "B", "C", "C"),
  value = c(2, 3, 1, 8),
  stringsAsFactors = FALSE
)
spread_with_multiple_values(test1, key, value, aggfunc = str_c, collapse = "-")
spread_with_multiple_values(test3, key, value, aggfunc = min)
spread_with_multiple_values(test3, key, value, aggfunc = mean)

# same output of tidyr::spread() if one value per key and no aggfunc
library(dplyr)
stocks <- data.frame(
 time = as.Date('2009-01-01') + 0:9,
 X = rnorm(10, 0, 1),
 Y = rnorm(10, 0, 2),
 Z = rnorm(10, 0, 4)
)
stocksm <- stocks \%>\% gather(stock, price, -time)
stocksm \%>\% spread_with_multiple_values(stock, price)
stocksm \%>\% tidyr::spread(stock, price)
stocksm \%>\% spread_with_multiple_values(time, price)
stocksm \%>\% tidyr::spread(time, price)

# Use 'convert = TRUE' to produce variables of mixed type
df <- data.frame(row = rep(c(1, 51), each = 3),
                 var = c("Sepal.Length", "Species", "Species_num"),
                 value = c(5.1, "setosa", 1, 7.0, "versicolor", 2))
df \%>\% spread_with_multiple_values(var, value) \%>\% str
df \%>\% tidyr::spread(var, value, convert = TRUE) \%>\% str

# Use sep non-NULL
spread_with_multiple_values(test2, key, value, sep = "_var_")
spread_with_multiple_values(df, var, value, sep = "_")
}
}
